# -*- coding: utf-8 -*-
"""assign_5th.ipynb

Automatically generated by Colaboratory.

"""

#Part A

#Example 1
#Given in TextBook
# rq = ['d3','d5','d9','d25','d39','d44','d56','d71','d89','d123']
# aq = ['d123','d84','d56','d6','d8','d9','d511','d129','d187','d25','d38','d48','d250','d113','d3']

#Example 2
# Taken arbitrarily by me
rq = ['d2','d444','d903','d710','d45','d12','d1','d999','d99','d345']
aq = ['d23','d67','d345','d90','d99','d678','d1','d12','d45','d350','d324','d676','d980','d710','d444']

#Importing
import pandas as pd
import numpy as np
import matplotlib 
from matplotlib import pyplot as plt

#Main Function which calculates recall and precision for the given rq and aq
def calculate_rp(rq,aq):
  rql = len(rq)
  c=0
  recall={}
  precision={}
  for i in range(len(aq)):
    if aq[i] in rq:
      c+=1
      recall[aq[i]]=round(c/rql,2)
      precision[aq[i]]=round(c/(i+1),2)
  else:
    pass
  return pd.DataFrame({"Recall Values":pd.Series(recall),"Precision Values":pd.Series(precision)})

res = calculate_rp(rq,aq)
# res.sort_values("Recall Values")
res

#Curve of Recall vs Precision
x = list(res["Recall Values"])


#To make both x and y equal, we insert some values manually
x.insert(0,0)
x.extend(np.arange(x.pop(),1.1,0.1))
x = [round(a,1) for a in x][:-1]
y = list(res["Precision Values"])
y.insert(0,1.0)
y.extend([0]*(len(x)-len(y)))

#Plotting the curve
plt.scatter(x,y,color='green')
plt.plot(x,y)
plt.xlabel = 'Recall'
plt.ylabel= 'Precision'
plt.show()

#Calculation of R-Precision
rql = len(rq)
setaq = aq[0:rql]
c=0
for i in setaq:
  if i in rq:
    c+=1
r_prec = c/rql
print ('R-Precision Value: ',r_prec)

#Part B
#Comparsion of both IR Algorithms
rq = ['d3','d5','d9','d25','d39','d44','d56','d71','d89','d123']
a1 = [ 'd123','d84','d56','d6','d8','d9','d511','d129','d187','d25','d38','d48','d250','d113','d3']
a2 = [ 'd112','d39','d34','d123','d434','d9','d319','d555','d33','d25','d11','d71','d89','d44','d3']

res_a1 = calculate_rp(rq,a1)
res_a2 = calculate_rp(rq,a2)
res_a1

# res_a2.sort_values("Recall Values")
res_a2

#Curve of Recall vs Precision for comparison
x = list(res_a1['Recall Values'])

#To make both x and y equal, we insert some values manually for the curve
x.insert(0,0)
x.extend(np.arange(x.pop(),1.1,0.1))
x = [round(a, 1) for a in x][:-1]

#For res_a1
y1 = list(res_a1['Precision Values'])
y1.insert(0,1.0)
y1.extend([0]*(len(x)-len(y1)))
plt.scatter(x,y1,color='green')
plt.plot(x,y1,color='black')

#For res_a2
y2 = list(res_a2['Precision Values'])
y2.insert(0,1.0)
y2.extend([0]*(len(x)-len(y2)))
plt.scatter(x,y2,color='red')
plt.plot(x,y2,color='black')

#Plotting the main curve
plt.xlabel = 'Recall Values'
plt.ylabel= 'Precision Values'
plt.show()

y = [a-b for (a, b) in zip(y1,y2)]
dl = pd.DataFrame({'Recall Values':x, 'Precision Values':y})
ax = dl.plot.bar(x='Recall Values', y='Precision Values')
print(ax)
print('Res A1 is better' if sum(y)>=0 else 'Res A2 is better')

#Part C
#Calculations of Harmonic Mean and E-Measure
#Example 1
# q = ['d3','d5','d9','d25','d39','d44','d56','d71','d89','d123']
# a1 = ['d123','d84','d56','d6','d8','d9','d511','d129','d187','d25','d38','d48','d250','d113','d3']

# Example 2
rq = ['d2','d444','d903','d710','d45','d12','d1','999','d99','d345']
aq = ['d23','d67','d345','d90','d99','d678','d1','d12','d45','d350','d324','d676','d980','d710','d444']
def calculation_of_harmonic_mean_and_e_measure(rq,aq):
  c = 0
  rql = len(rq)
  recall={}
  precision={}
  hm={} 
  em1={} 
  em2 = {}
  em3={}
  for i in range(len(aq)):
    if aq[i] in rq:
      c += 1
      recall[aq[i]] = (round(c/rql,2))
      precision[aq[i]] = (round(c/(i+1),2))

      hm[aq[i]] = round(2/((1/recall[aq[i]])+(1/precision[aq[i]])),2)
      
      #Setting b>1 to make user more interested in precision than recall
      b = 2
      em1[aq[i]] = round((1+(b**2))/(((b**2)/recall[aq[i]])+(1/precision[aq[i]])),2)


      #Setting b<1 to make user more interested in recall than precision
      b = 0.1
      em2[aq[i]] = round((1+(b**2))/(((b**2)/recall[aq[i]])+(1/precision[aq[i]])),2)

      #Setting b=1 or to make things better and easier em = 1 - hm
      em3[aq[i]] = round(1-hm[aq[i]],2)
  else:
    pass
  
  return pd.DataFrame({'Recall Values':pd.Series(recall),'Precision Values':pd.Series(precision),'Harmonic mean':pd.Series(hm),'E-Measure (b>1)':pd.Series(em1),'E-Measure (b<1)':pd.Series(em2),"E-Measure (b=1)":pd.Series(em3)})


#Final Calculation Of Harmonic Mean
res = calculation_of_harmonic_mean_and_e_measure(rq,aq)
res
